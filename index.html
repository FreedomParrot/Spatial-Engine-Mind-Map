<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE LABYRINTH | Spatial Mind</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #0a0a0c; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 20px; left: 20px; pointer-events: none; color: rgba(255,255,255,0.5); }
        .instructions { font-size: 12px; text-transform: uppercase; letter-spacing: 2px; }
        #input-overlay { 
            position: absolute; display: none; 
            background: rgba(20, 20, 25, 0.9); border: 1px solid #333;
            padding: 10px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        input { background: transparent; border: none; color: white; outline: none; font-size: 16px; width: 200px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="instructions">Double Click to Create â€¢ Drag to Move | Created from freedomparrot@proton.me</div>
    </div>

    <div id="input-overlay">
        <input type="text" id="node-input" placeholder="Type a thought..." />
    </div>

    <canvas id="canvas"></canvas>

    <script>
 const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('input-overlay');
const input = document.getElementById('node-input');

let nodes = JSON.parse(localStorage.getItem('labyrinth_nodes')) || [];

let camera = { x: 0, y: 0, zoom: 1, isPanning: false, lastMouse: { x: 0, y: 0 } };
let isDraggingNode = false;
let selectedNode = null;
let activeNode = null;
let tempCoords = { x: 0, y: 0 };

function init() {
    window.addEventListener('resize', resize);
    resize();
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel, { passive: false });
    canvas.addEventListener('dblclick', onDoubleClick);
    input.addEventListener('keydown', (e) => { if (e.key === 'Enter') finalizeNode(); });
    requestAnimationFrame(render);
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

function toWorld(sX, sY) {
    return {
        x: (sX - canvas.width / 2 - camera.x) / camera.zoom,
        y: (sY - canvas.height / 2 - camera.y) / camera.zoom
    };
}

// --- INTERACTION ---

function onMouseDown(e) {
    const worldPos = toWorld(e.clientX, e.clientY);
    selectedNode = nodes.find(node => Math.hypot(node.x - worldPos.x, node.y - worldPos.y) < 30 / camera.zoom);
    if (selectedNode) {
        isDraggingNode = true;
        activeNode = selectedNode;
    } else {
        camera.isPanning = true;
        camera.lastMouse = { x: e.clientX, y: e.clientY };
    }
}

function onMouseMove(e) {
    if (isDraggingNode && selectedNode) {
        const worldPos = toWorld(e.clientX, e.clientY);
        selectedNode.x = worldPos.x;
        selectedNode.y = worldPos.y;

        // SINGULARITY LOGIC: Check distance to (0,0)
        const distToCenter = Math.hypot(selectedNode.x, selectedNode.y);
        if (distToCenter < 50) {
            // Delete node if dragged into the black hole
            nodes = nodes.filter(n => n.id !== selectedNode.id);
            onMouseUp(); // Force drop
            save();
        }
    } else if (camera.isPanning) {
        camera.x += (e.clientX - camera.lastMouse.x);
        camera.y += (e.clientY - camera.lastMouse.y);
        camera.lastMouse = { x: e.clientX, y: e.clientY };
    }
}

function onMouseUp() { if (isDraggingNode) save(); isDraggingNode = false; camera.isPanning = false; }

function onWheel(e) {
    e.preventDefault();
    camera.zoom *= (1 - e.deltaY * 0.001);
    camera.zoom = Math.min(Math.max(0.05, camera.zoom), 3); 
}

function onDoubleClick(e) {
    tempCoords = toWorld(e.clientX, e.clientY);
    overlay.style.display = 'block';
    overlay.style.left = `${e.clientX}px`; overlay.style.top = `${e.clientY}px`;
    input.focus();
}

function finalizeNode() {
    if (input.value.trim() !== "") {
        nodes.push({
            id: Date.now(), x: tempCoords.x, y: tempCoords.y,
            text: input.value, color: `hsl(${Math.random() * 360}, 80%, 60%)`,
            velocity: { x: (Math.random()-0.5)*0.1, y: (Math.random()-0.5)*0.1 }
        });
        save();
    }
    input.value = ""; overlay.style.display = 'none';
}

function save() { localStorage.setItem('labyrinth_nodes', JSON.stringify(nodes)); }

// --- RENDER ENGINE ---

function drawSingularity(ctx) {
    const pulse = Math.sin(Date.now() / 400) * 5;
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 40 + pulse);
    gradient.addColorStop(0, 'rgba(0,0,0,1)');
    gradient.addColorStop(0.5, 'rgba(20,0,40,1)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, 50 + pulse, 0, Math.PI * 2);
    ctx.fill();
    
    // Core event horizon ring
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath();
    ctx.arc(0, 0, 15 + pulse/2, 0, Math.PI * 2);
    ctx.stroke();
}

function render() {
    ctx.fillStyle = '#030305';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2 + camera.x, canvas.height / 2 + camera.y);
    ctx.scale(camera.zoom, camera.zoom);

    drawSingularity(ctx);

    nodes.forEach((nodeA, i) => {
        // Drift
        nodeA.x += nodeA.velocity?.x || 0; nodeA.y += nodeA.velocity?.y || 0;

        // Connections
        nodes.slice(i + 1).forEach(nodeB => {
            const dist = Math.hypot(nodeA.x - nodeB.x, nodeA.y - nodeB.y);
            if (dist < 350) {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.max(0, 0.1 - dist/3500)})`;
                ctx.moveTo(nodeA.x, nodeA.y); ctx.lineTo(nodeB.x, nodeB.y);
                ctx.stroke();
            }
        });
    });

    nodes.forEach(node => {
        ctx.shadowBlur = (node === activeNode) ? 20 : 10;
        ctx.shadowColor = node.color;
        ctx.fillStyle = node.color;
        ctx.beginPath(); ctx.arc(node.x, node.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = `${14}px Inter`;
        ctx.fillText(node.text, node.x + 12, node.y + 4);
    });

    ctx.restore();
    requestAnimationFrame(render);
}
init();
    </script>
</body>
</html>
